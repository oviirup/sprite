import { parse } from 'node-html-parser';
import pi from 'picocolors';
import svgo from 'svgo';
import { PresetDefaultOverrides } from 'svgo/plugins/plugins-types';
import { IconData, ResolvedConfig } from '../types';
import { relativePath, writeFile } from './files';
import { logger, outputFileNames } from './helpers';

type SymbolProps = {
  name: string;
  content: string;
  config: ResolvedConfig;
};
export function convertToSymbol({ name, content, config }: SymbolProps) {
  const { svgoPlugins } = config;
  const svgRoot = parse(content);
  const svg = svgRoot.getElementsByTagName('svg')[0];
  if (!svg) throw new Error('Unable to parse svg contents');

  svg.tagName = 'symbol'; // rename the tag
  svg.setAttribute('id', name); // give icon id

  const output = svgo.optimize(svg.toString(), {
    floatPrecision: 2,
    plugins: svgoPlugins,
  });

  return output.data;
}

type SpriteFileProps = {
  svgIcons: IconData[];
  outputPath: string;
  config: ResolvedConfig;
  timer?: number;
};
export async function createSpriteFiles({
  svgIcons,
  outputPath,
  config,
  timer,
}: SpriteFileProps) {
  const { iconPrefix = '', cwd } = config;
  const files = outputFileNames(outputPath, config.outFileSuffix);

  // svg icons with prefixed id
  const icons = svgIcons.map((e) => ({ ...e, name: iconPrefix + e.name }));

  // sprite symbols
  const symbols = icons.map((item) => convertToSymbol({ ...item, config }));
  const spriteContent = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by @oviirup/sprite -->`,
    `<svg xmlns="http://www.w3.org/2000/svg">`,
    ...symbols,
    `</svg>`,
  ].join('\n');
  try {
    await writeFile(files.sprite, spriteContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.sprite, cwd);
      logger(`${pi.green('spite')}: ${_path}`, timer);
    });
  } catch {
    logger(pi.red(`unable to write file ${files.sprite}`));
  }
  // reset timer
  timer = performance.now();
  // sprite metadata
  const metadata = Object.fromEntries(icons.map((e) => [e.name, 0]));
  const metaContent = JSON.stringify(metadata);
  try {
    await writeFile(files.meta, metaContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.meta, cwd);
      logger(`${pi.green('meta')}:  ${_path}`, timer);
    });
  } catch {
    logger(pi.red(`unable to write file ${files.meta}`));
  }

  return { outputFiles: files };
}
