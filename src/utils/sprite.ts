import { parse } from 'node-html-parser';
import * as pi from 'picocolors';
import * as svgo from 'svgo';
import { PresetDefaultOverrides } from 'svgo/plugins/plugins-types';
import { IconData, ResolvedConfig } from '../types';
import { relativePath, writeFile } from './files';
import { logger, outputFileNames } from './helpers';

type SymbolProps = {
  name: string;
  content: string;
  config: ResolvedConfig;
};
export function convertToSymbol({ name, content, config }: SymbolProps) {
  const { svgoPlugins } = config;
  const svgRoot = parse(content);
  const svg = svgRoot.getElementsByTagName('svg')[0];
  if (!svg) throw new Error('Unable to parse svg contents');

  svg.tagName = 'symbol'; // rename the tag
  svg.setAttribute('id', name); // give icon id

  const presetOverrides: PresetDefaultOverrides = {
    cleanupIds: false,
    removeHiddenElems: false,
    removeViewBox: false,
  };

  const removeAttrs = ['xmlns'];

  const output = svgo.optimize(svg.toString(), {
    floatPrecision: 2,
    plugins: [
      { name: 'preset-default', params: { overrides: presetOverrides } },
      { name: 'removeAttrs', params: { attrs: removeAttrs } },
      ...svgoPlugins,
    ],
  });

  return output.data;
}

type SpriteFileProps = {
  svgIcons: IconData[];
  config: ResolvedConfig;
  timer?: number;
};
export async function createSpriteFiles({
  svgIcons,
  config,
  timer,
}: SpriteFileProps) {
  const { prefix = '', output, cwd } = config;
  const files = outputFileNames(output);

  // svg icons with prefixed id
  const icons = svgIcons.map((e) => ({ ...e, name: prefix + e.name }));

  // sprite symbols
  const symbols = icons.map((item) => convertToSymbol({ ...item, config }));
  const spriteContent = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by @oviirup/sprite -->`,
    `<svg xmlns="http://www.w3.org/2000/svg">`,
    ...symbols,
    `</svg>`,
  ].join('\n');
  try {
    await writeFile(files.sprite, spriteContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.sprite, cwd);
      logger(`${pi.green('spite')}: ${_path}`, timer);
    });
  } catch {
    return { error: `unable to write file ${files.sprite}` };
  }

  // sprite metadata
  const metadata = Object.fromEntries(icons.map((e) => [e.name, 0]));
  const metaContent = JSON.stringify(metadata);
  try {
    await writeFile(files.meta, metaContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.meta, cwd);
      logger(`${pi.green('meta')}:  ${_path}`);
    });
  } catch {
    return { error: `unable to write file ${files.meta}` };
  }

  return { outputFiles: files };
}
