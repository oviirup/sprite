import path from 'path';
import { parse } from 'node-html-parser';
import * as pi from 'picocolors';
import * as svgo from 'svgo';
import { PresetDefaultOverrides } from 'svgo/plugins/plugins-types';
import { IconData } from '../types';
import { composeFileName, relativePath, writeFile } from './files';
import { getByteSize, getHash, logger, outputFileNames } from './helpers';

type SymbolProps = { name: string; content: string };
export function convertToSymbol({ name, content }: SymbolProps) {
  const svgRoot = parse(content);
  const svg = svgRoot.getElementsByTagName('svg')[0];
  if (!svg) throw new Error('Unable to parse svg contents');

  svg.tagName = 'symbol'; // rename the tag
  svg.setAttribute('id', name); // give icon id

  const presetOverrides: PresetDefaultOverrides = {
    cleanupIds: false,
    removeHiddenElems: false,
    removeViewBox: false,
  };

  const removeAttrs = ['xmlns'];

  const output = svgo.optimize(svg.toString(), {
    floatPrecision: 2,
    plugins: [
      { name: 'preset-default', params: { overrides: presetOverrides } },
      { name: 'removeAttrs', params: { attrs: removeAttrs } },
    ],
  });

  return output.data;
}

type SpriteFileProps = {
  svgIcons: IconData[];
  outputPath: string;
  cwd: string;
  timer?: number;
};
export async function createSpriteFiles({
  svgIcons,
  outputPath,
  cwd,
  timer,
}: SpriteFileProps) {
  const files = outputFileNames(outputPath);

  // sprite symbols
  const symbols = svgIcons.map(convertToSymbol);
  const spriteContent = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by @oviirup/sprite -->`,
    `<svg xmlns="http://www.w3.org/2000/svg">`,
    ...symbols,
    `</svg>`,
  ].join('\n');
  try {
    await writeFile(files.sprite, spriteContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.sprite, cwd);
      logger(`${pi.green('spite')}: ${_path}`, timer);
    });
  } catch {
    return { error: `unable to write file ${files.sprite}` };
  }

  // sprite metadata
  const metadata = Object.fromEntries(svgIcons.map((e) => [e.name, 0]));
  const metaContent = JSON.stringify(metadata);
  try {
    await writeFile(files.meta, metaContent).then((res) => {
      if (!res) return;
      const _path = relativePath(files.meta, cwd);
      logger(`${pi.green('meta')}:  ${_path}`);
    });
  } catch {
    return { error: `unable to write file ${files.meta}` };
  }

  return { outputFiles: files };
}
