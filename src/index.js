#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { CLI } from '@/const';
import {
  compareArrays,
  ensureDirectory,
  parseFileContent,
  readFile,
  resolveConfig,
  writeFile,
} from '@/utils';
import { Command } from 'commander';
import parse from 'node-html-parser';
import * as pi from 'picocolors';
import * as svgo from 'svgo';

// exit process on termination
['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGKILL'].forEach((signal) =>
  process.on(signal, () => {
    console.log(pi.red('Exiting'));
    process.stdout.write('\x1B[?25h');
    process.exit();
  }),
);

const helper = (text, def) => {
  return !def ? text : text + pi.dim(`  (default: ${def})`);
};

const createSpriteCLI = new Command(CLI.name)
  .description(CLI.description)
  .usage(`${pi.dim('[options]')}`)
  .version(CLI.version)
  .option(
    '-i, --input <folder>',
    helper('Specify the input folder', 'current dir'),
  )
  .option(
    '-o, --output <file>',
    helper('Specify the output file', './sprite.svg'),
  )
  .option('    --dts <file>', helper('Specify the type definitions file'))
  .option('-e, --extract', helper('Extract icons from sprite'))
  .option('-p, --prefix', helper('Prefix for icon names'))
  .option('    --force', helper('Override existing files'))
  .option('    --no-emit', helper('Do not generate sprite or types'))
  .action(generateSprite);

createSpriteCLI.parseAsync().catch(async (reason) => {
  console.log(`Aborting installation.`);
  if (reason.command) {
    console.log(`  ${pi.cyan(reason.command)} has failed.`);
  } else {
    console.log(`${pi.red('Unexpected error. Please report it as a bug:')}`);
    console.log(`  ${reason}`);
  }
  process.exit(1);
});

/**
 * Generate svg sprite from svg files
 *
 * @param {SpriteOptions} options
 */
async function generateSprite(options) {
  const config = await resolveConfig();
  const opts = Object.assign(config, options);
  const cwd = path.resolve(process.cwd(), opts.cwd);

  // resolve all paths
  opts.input = path.resolve(cwd, opts.input);
  opts.output = path.resolve(cwd, opts.output);
  opts.dts = opts.dts && path.resolve(cwd, opts.dts);

  // do not generate file for extraction task
  if (opts.extract) {
    opts.emit = false;
    if (!fs.existsSync(opts.output)) {
      console.log(pi.red(`× sprite not found`));
      process.exit(1);
    }
    // extract icons from sprite
    await extractFiles(opts);
    return;
  }

  // check if the input directory exists
  if (!fs.existsSync(opts.input)) {
    if (fs.existsSync(opts.output)) {
      await extractFiles(opts);
    } else {
      console.log(pi.red(`× opts. directory not found`));
      console.log(pi.dim(`  keep all icons inside "${opts.input}"`));
      process.exit(1);
    }
  }
  const files = fs.readdirSync(opts.input).filter((f) => f.endsWith('.svg'));

  if (files.length === 0) {
    console.log(pi.dim(`× no svg files found in "${opts.input}"`));
  } else if (!opts.emit) {
    console.log(pi.dim('× no file is generated'));
  } else {
    createSpriteFile(files, opts);
    createTypesFile(files, opts);
  }
}

/**
 * Generate the svg sprite file
 *
 * @param {string[]} files
 * @param {SpriteOptions} opts
 */
async function createSpriteFile(files, opts) {
  const _sprites = await parseFileContent(opts.output, /id="([^"]+)/g);
  const iconNames = files.map((file) => iconName(file));
  const isUpdated = compareArrays(iconNames, _sprites.iconNames);
  if (!opts.force && isUpdated) {
    console.log(pi.gray('✓ icon sprites are up to date'));
    return;
  }
  // create svg symbols for each files
  const inputFiles = files.map((file) => path.join(opts.input, file));
  const symbol = await Promise.all(
    inputFiles.map(async (file) => {
      const rawSVG = await readFile(file);
      const svgRoot = parse(rawSVG);
      const svg = svgRoot.querySelector('svg');
      if (!svg) throw new Error('No SVG element found');
      svg.removeAttribute('height');
      svg.removeAttribute('width');
      // create symbol from svg
      svg.tagName = 'symbol';
      svg.setAttribute('id', iconName(file));
      // prettier-ignore
      const removeAttrs = ['xmlns','fill','stroke','stroke-width','stroke-linecap','stroke-linejoin'];
      const paramsOverride = {
        removeHiddenElems: false,
        cleanupIds: false,
        mergePaths: false,
      };
      const output = svgo.optimize(svg.toString(), {
        floatPrecision: 2,
        plugins: [
          { name: 'preset-default', params: { overrides: paramsOverride } },
          { name: 'removeAttrs', params: { attrs: removeAttrs } },
        ],
      });
      return output.data;
    }),
  );

  const output = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by pnpm icogen -->`,
    `<svg xmlns="http://www.w3.org/2000/svg">`,
    `<defs>`,
    ...symbol,
    `</defs>`,
    `</svg>`,
    '', // trailing newline
  ].join('\n');

  const outFile = await writeFile(opts.output, output, opts.force);
  if (outFile) {
    console.log(pi.green('✓'), pi.dim('sprite:'), outFile);
  }
}

/**
 * Generate types for icon names
 *
 * @param {string[]} files
 * @param {SpriteOptions} opts
 */
async function createTypesFile(files, opts) {
  if (!opts.dts) return;
  const _types = await parseFileContent(opts.dts, /['"]([^"']+)/g);
  const iconNames = files.map((file) => iconName(file));
  const isUpdated = compareArrays(iconNames, _types.iconNames);
  if (!opts.force && isUpdated) {
    console.log(pi.gray('✓ type definitions are up to date'));
    return;
  }
  // create the types file
  const output = [
    '// This file is generated by pnpm icogen',
    'export type IconName =',
    iconNames.map((n) => `  | '${n}'`).join('\n') + ';\n',
  ].join('\n');

  const outFile = await writeFile(opts.dts, output, opts.force);
  if (outFile) {
    console.log(pi.green('✓'), pi.dim('types: '), outFile);
  }
}

/**
 * Extract svg icons from sprite
 *
 * @param {SpriteOptions} opts
 */
async function extractFiles(opts) {
  // make sure the target directory exists
  await ensureDirectory(opts.input);
  // parse the svg sprite
  const rawSprite = await readFile(opts.output);
  const spriteRoot = parse(rawSprite);
  const symbols = spriteRoot.querySelectorAll('symbol[id]');
  symbols.forEach((symbol) => {
    const id = symbol.getAttribute('id');
    if (!id?.trim()) return;
    symbol.tagName = 'svg';
    symbol.removeAttribute('id');
    symbol.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    symbol.setAttribute('width', '24');
    symbol.setAttribute('height', '24');
    symbol.setAttribute('viewBox', '0 0 24 24');
    symbol.setAttribute('fill', 'none');
    symbol.setAttribute('stroke', 'currentColor');
    symbol.setAttribute('stroke-width', '2');
    symbol.setAttribute('stroke-linecap', 'round');
    symbol.setAttribute('stroke-linejoin', 'round');

    const output = svgo.optimize(symbol.toString());
    const filePath = path.join(opts.input, `${id}.svg`);
    writeFile(filePath, output.data);
  });
  const relPath = path.relative(process.cwd(), opts.input);
  console.log(pi.gray(`✓ extracted svg icons to ${relPath}`));
}

/**
 * Get the icon name from file
 *
 * @param {string} file
 */
function iconName(file) {
  return path.basename(file).replace(/\.svg$/, '');
}
